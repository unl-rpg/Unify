/********************************************************************************
 * File Name          : testStand.c
 * Author             : Jack Shaver
 * Date               : 4/11/2025
 * Description        : Test Stand Source
 ********************************************************************************/

#include "testStand.h"
 
// Good to have
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_log.h"

// Used for the console
//#include "nvs.h"
//#include "nvs_flash.h"
#include "esp_console.h"
#include "argtable3/argtable3.h"

// Custom Libraries
#include "pins.h" 
#include "i2c.h" // i2c bus (dev only)
#include "blink.h" // blink led
#include "buzzer.h" // buzzer
#include "spi.h"
#include "leds.h"
#include "adc.h" // the adc in the s3
#include "sd.h"
#include "logging.h"
#include "espnow.h"

// Console
static void consoleInit(); 

// System
static void systemRegisterCommands();
static void systemPowerOff();
static void systemFire();
static void systemAbort();

SemaphoreHandle_t fireTaskBlockSemaphore = NULL; // blocks the task until interrupt
static void fireTask(void *arg);

// I2C Interrupt
SemaphoreHandle_t i2cTaskBlockSemaphore = NULL; // blocks the task until interrupt
static void inputInterruptInit(gpio_num_t gpioPin, gpio_int_type_t interruptType, gpio_isr_t interruptHandler);
void IRAM_ATTR inputExpanderInterrupt();
static void i2cTask(void *arg);

// Espnow 
void espnowReceiveCallback(const esp_now_recv_info_t* mac_addr, const unsigned char* data, int len);


static bool checkIsBaseStation(){
	ESP_ERROR_CHECK(gpio_reset_pin(CONFIG_PIN));
	ESP_ERROR_CHECK(gpio_set_direction(CONFIG_PIN, GPIO_MODE_INPUT));
	return gpio_get_level(CONFIG_PIN); // Returns 1 if its a base station
}

void testStandInit(){
	
	if(checkIsBaseStation() == true){
		printf("Cannot configure hardware as a Test Stand. Detected hardware configuration for a Base Station.\n");
		printf("Aborting Initialization.\n");
		return;
	}
	
	blinkInit(BLINK_PIN);
	buzzerInit(BUZZER_PIN);
	i2cInit(I2C_SCL_PIN, I2C_SDA_PIN);
	ledsInit();
	adcInit();

	// Init the interrupt from the I2C GPIO Expander
	i2cTaskBlockSemaphore = xSemaphoreCreateBinary();   
	inputInterruptInit(I2C_INTERRUPT_PIN, GPIO_INTR_NEGEDGE, inputExpanderInterrupt);
	xTaskCreate(i2cTask, "i2cTask", 4096, NULL, 7, NULL);
	
	
	// Init the task for managing the fire sequence
	fireTaskBlockSemaphore = xSemaphoreCreateBinary();
	xTaskCreate(fireTask, "fireTask", 4096, NULL, 2, NULL);
	
	sdInit();
	spiInit(SPI_MISO_PIN, SPI_MOSI_PIN, SPI_CLK_PIN, SPI_CS_PIN);
	loggingInit();

	espnowInit(espnowBaseStationMac);
	espnowRegisterRecieveCallback(espnowReceiveCallback);

	//espnowGetMAC(espnowTestStandMac);
	//printf("Test Stand MAC Address: 0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x", 
	//	espnowTestStandMac[0], espnowTestStandMac[1], espnowTestStandMac[2], 
	//	espnowTestStandMac[3], espnowTestStandMac[4], espnowTestStandMac[5]
	//);
	
	consoleInit();
	
}

// ================================= ESPNOW RECIEVE =====================================
void espnowReceiveCallback(const esp_now_recv_info_t* mac_addr, const unsigned char* data, int len){
	uint16_t command = data[0];
	printf("Espnow Recieved Command: 0x%02x\n", command);
	
	switch(command){
	case espnowAcknowledgeCommand:
		printf("Recieved acknowledge from Base Station\n\n");
		break;
	case espnowPingCommand:
		espnowSendCommand(espnowAcknowledgeCommand);
		break;
	case espnowFireCommand:
		espnowSendCommand(espnowAcknowledgeCommand);
		systemFire();
		break;
	case espnowAbortCommand:
		espnowSendCommand(espnowAcknowledgeCommand);
		systemAbort();
		break;
	case espnowUnrecognizedCommand:
		printf("Base Station did not recognize last Espnow Command\n\n");
		break;
	default:
		printf("Unrecognized Espnow Command\n\n");
		espnowSendCommand(espnowUnrecognizedCommand);
		break;
	}
}

// ================================= I2C GPIO EXPANDERS INPUT INTERRUPT =====================================
// Sets the gpio as an input, with an ISR, no internal pull resistors
void inputInterruptInit(gpio_num_t gpioPin, gpio_int_type_t interruptType, gpio_isr_t interruptHandler){
    ESP_ERROR_CHECK(gpio_reset_pin(gpioPin));
    ESP_ERROR_CHECK(gpio_set_direction(gpioPin, GPIO_MODE_INPUT)); 
    ESP_ERROR_CHECK(gpio_set_intr_type(gpioPin, interruptType));
    ESP_ERROR_CHECK(gpio_install_isr_service(0));
    ESP_ERROR_CHECK(gpio_isr_handler_add(gpioPin, interruptHandler, NULL));
}

// Interrupt generated by the I2C GPIO Expander configured as an input
void IRAM_ATTR inputExpanderInterrupt(){
    static BaseType_t higherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(i2cTaskBlockSemaphore, &higherPriorityTaskWoken);
}

// Read the i2c input expander, update the stalls or battery status
void i2cTask(void *arg){
	uint8_t diff = 0;
	uint8_t values = 0;
	
	int powerDownCount = 3;
	bool powerDownOnRelease = false;
    while(1){
        if(xSemaphoreTake(i2cTaskBlockSemaphore, 0xffff) == pdTRUE){ 
			i2cGetInterruptSources(&diff, &values);
			if(diff & 0x01){
				// update key state;
				if((values & 0x01) == 1){
					ledsClearError(); // clear the errors when the safety key is activated
				};
			}
			if(diff & 0x02){
				// abort button
				systemAbort();
			}
			if(diff & 0x04){ // power button interrupt source
				if(values & 0x04){ // power button pressed
					printf("Hold for 3 seconds.\n");
					do{
						printf("%d\n", powerDownCount);
						vTaskDelay(500 / portTICK_PERIOD_MS);
						powerDownCount = powerDownCount - 1;
					}while(powerDownCount > 0);
					
					if(i2cGetGpioSignal(I2C_POWER_BUTTON)){ // power button held
						printf("Release power button now.\n");
						powerDownOnRelease = true;
					}else{
						printf("Did not power off.\n");
						powerDownCount = 3;
					}
				}else{
					if(powerDownOnRelease == true){
						printf("Powering off...\n");
						systemPowerOff();
					}
				}
			}
			if(diff & 0x08){
				// update charge detection
				// When the charger is active, it is rapidly toggling the status output
				// This is causing a ton of interrupts here, so moved the charge led to the usb current detection
				// Sould cut the trace on the circuit board to prevent this
				//printf("test");
			}
			if(diff & 0x10){
				// update igniter detection
			}
			if(diff & 0x20){
				// update sd state
			}
			if(diff & 0x40){
				// update usb detection
			}
			if(diff & 0x80){
				// update usb current detection

				if(values & 0x80){
					ledsSetState(ledCharge, ledOn);
				}else{
					ledsSetState(ledCharge, ledOff);
				}
			}
        }
    }
}


// ================================= SYSTEM CONSOLE INTERFACE ===============================================
static struct {
	struct arg_lit *querySystemType;
	struct arg_lit *ping;
	struct arg_lit *temperature;
	struct arg_lit *battery;
	struct arg_lit *powerOff; 
    struct arg_end *end;
} system_cmd_args;

static int systemCommands(int argc, char **argv){
	static const char* TAG = "system-commands";
	
	int nerrors = arg_parse(argc, argv, (void  **) &system_cmd_args);
	if (nerrors != 0) {
        arg_print_errors(stderr, system_cmd_args.end, argv[0]);
        return 1;
    }
	
	if(system_cmd_args.querySystemType->count != 0){ // return the system type
		printf("Test Stand\n\n");
	}
	
	if(system_cmd_args.ping->count != 0){ // ping the other end of the espnow connection
		printf("Pinging the Base Station...\n\n");
		espnowSendCommand(espnowPingCommand);
	}
	
	if(system_cmd_args.temperature->count != 0){
		printf("PCB Temperature: %2.6f C\n\n", adcRead(pcbTemperature));
	}
	
	if(system_cmd_args.battery->count != 0){
		printf("Battery Voltage: %2.6f V\n\n", adcRead(batteryVoltage));
	}
	
	if(system_cmd_args.powerOff->count != 0){ // power off the device
		printf("Powering off...\n\n");
		systemPowerOff();
	}
	
	return 0;
}

void systemRegisterCommands(){
	system_cmd_args.querySystemType = arg_lit0("q", "query", "Returns the system type");
	system_cmd_args.ping = arg_lit0("p", "ping", "Pings the base station");
	system_cmd_args.temperature = arg_lit0("t", "temperature", "Checks the PCB temperature");
	system_cmd_args.battery = arg_lit0("b", "battery", "Checks the battery voltage");
	system_cmd_args.powerOff = arg_lit0("o", "off", "Powers off the system");
	system_cmd_args.end = arg_end(2);
	
	const esp_console_cmd_t cmd_reg = {
		.command = "system",
		.help = "Control the local system",
		.hint = NULL,
		.func = &systemCommands,
		.argtable = &system_cmd_args
	};
	
	ESP_ERROR_CHECK(esp_console_cmd_register(&cmd_reg));
}
// ================================= System Commands ==============================================
void systemPowerOff(){
	i2cSetGpioSignal(I2C_POWER_OFF, 1);
}

static bool abortFire = false;
static int countdown = 0;
void systemFire(){
	if(i2cGetGpioSignal(I2C_KEY) == 1){
		espnowSendCommand(espnowBadKeyStateCommand);
		return;
	}
	
	if(i2cGetGpioSignal(I2C_SD_CARD_DETECT) == 0){
		espnowSendCommand(espnowNoSdCardCommand);
		return;
	}
	
	if(i2cGetGpioSignal(I2C_IGNITER_DETECT) == 0){
		espnowSendCommand(espnowBadIgniterCommand);
		return;
	}
	
	espnowSendCommand(espnowConfirmCountdown);

	countdown = 5;
	abortFire = false;
	xSemaphoreGive(fireTaskBlockSemaphore);
}

void systemAbort(){
	abortFire = true;
	loggingStop();
}


void fireTask(void *arg){
	 while(1){
        if(xSemaphoreTake(fireTaskBlockSemaphore, 0xffff) == pdTRUE){ 
			buzzerSetEnable(true);
			//ledsSetState(ledStatus, ledFlashing); 
		
			while(1){
				if(abortFire == true){
					break;
				}
				if(countdown <= 0){
					break;
				}

				countdown--;
				vTaskDelay(1000/ portTICK_PERIOD_MS);
			};
			
			buzzerSetEnable(false);
			//ledsSetState(ledStatus, ledOff); 
		
			if(abortFire == true){
				espnowSendCommand(espnowAbortConfirmationCommand);
				abortFire = false;
				break;
			}
			
			if(i2cGetGpioSignal(I2C_KEY) == 1){
				espnowSendCommand(espnowBadKeyStateCommand);
				break;
			}
			
			loggingStart();
			vTaskDelay(100/ portTICK_PERIOD_MS);
			i2cSetGpioSignal(I2C_IGNITER_ENABLE, true);
			
			vTaskDelay(1000/ portTICK_PERIOD_MS);
			i2cSetGpioSignal(I2C_IGNITER_ENABLE, false);
			
			if(i2cGetGpioSignal(I2C_IGNITER_DETECT) == 0){
				espnowSendCommand(espnowGoodFireCommand);
			}else{
				espnowSendCommand(espnowBadFireCommand);
				ledsReportError(0); // Turn on error led if there was a bad fire
			}
		}	
	 }
}

// ================================= CONSOLE INTERFACE ==============================================
void consoleInit(){
	//initialize_nvs();
	
	// The order determines the position they are displayed by the help command
	esp_console_register_help_command();
	systemRegisterCommands();
	i2cRegisterCommands(); // i2c io expanders
	//blinkRegisterCommands(); // blinking led
	buzzerRegisterCommands(); // buzzer
	ledsRegisterCommands(); // front panel leds
	//espnowRegisterCommands(); // wireless comms
	//adcRegisterCommands(); // internal adc, temperature and battery
	spiRegisterCommands(); // external adc, rear panel sensors
	//sdRegisterCommands(); // sd card
	//loggingRegisterCommands(); // monitoring and logging

	esp_console_repl_t *repl = NULL;
    esp_console_repl_config_t repl_config = ESP_CONSOLE_REPL_CONFIG_DEFAULT();
	repl_config.prompt = "Unify TestStand>";
    repl_config.max_cmdline_length = 1024;
	
	// Make sure to set CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG=y in the sdkconfig file. 
	// esp_console.h uses this config to enable the USB Serial JTAG console functions
	esp_console_dev_usb_serial_jtag_config_t hw_config = ESP_CONSOLE_DEV_USB_SERIAL_JTAG_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_console_new_repl_usb_serial_jtag(&hw_config, &repl_config, &repl));
	
	ESP_ERROR_CHECK(esp_console_start_repl(repl));
}